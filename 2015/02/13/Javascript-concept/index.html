<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Javascript概念整理(持续更新) · iuunhao</title><meta name="description" content="Javascript概念整理(持续更新) - iuunhao"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="iuunhao"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/111246729" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/iuunhao" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Javascript概念整理(持续更新)</h1><div class="post-info">2015年2月13日</div><div class="post-content"><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>当函数可以记住并访问所在的作用域(全局作用域除外)时，就产生了闭包，即使函数是在当前作用域之外执行。</p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>作用域链，是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。</p>
<h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><ul>
<li>全局环境</li>
<li>函数环境</li>
<li>eval</li>
</ul>
<p>当代码在执行过程中，遇到以上三种情况，都会生成一个执行上下文，放入栈中，而处于栈顶的上下文执行完毕之后，就会自动出栈，栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。</p>
<p>全局上下文在浏览器窗口关闭后出栈。</p>
<a id="more"></a>
<h2 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h2><ul>
<li><p>检查当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。</p>
</li>
<li><p>检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。</p>
</li>
<li><p>全局上下文有一个特殊的地方，它的变量对象，就是window对象。而这个特殊，在this指向上也同样适用，this也是指向window。</p>
</li>
</ul>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>this的指向，是在函数被调用的时候确定的，在函数执行过程中，this一旦被确定，就不可更改了。</p>
<ul>
<li>如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。</li>
<li>如果函数独立调用，那么该函数内部的this，则指向undefined,如果在严格模式，this则指向window。</li>
<li>如果是构造函数，那么this指向实例化对象。</li>
<li>call、apply可以改变this的指向</li>
</ul>
<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p><strong>构造函数中</strong></p>
<blockquote>
<p>属性与方法为当前实例单独拥有，只能被当前实例访问，并且每声明一个实例，其中的方法都会被重新创建一次。</p>
</blockquote>
<p><strong>原型中</strong></p>
<blockquote>
<p>属性与方法为所有实例共同拥有，可以被所有实例访问，新声明实例不会重复创建方法。</p>
</blockquote>
<p><strong>模块作用域中</strong></p>
<blockquote>
<p>属性和方法不能被任何实例访问，但是能被内部方法访问，新声明的实例，不会重复创建相同的方法。</p>
</blockquote>
</div></article></div></main><footer><div class="paginator"><a href="/2014/09/27/Sublime-config/" class="prev">上一篇</a><a href="/2016/03/26/Atom-for-vim/" class="next">下一篇</a></div><div class="copyright"><p>© 2014 - 2017 <a href="http://yoursite.com">iuunhao</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>